Phase 6 - Cash management and bank reconciliation
0) Scope and dependencies

Depends on Phase 2 (payments pipeline, outbox, posting).

Goals: originate ACH, ingest returns, integrate optional RTP or card rails, ingest bank statements (BAI2 and CAMT.053), reconcile against internal ledger, and surface exceptions.

1) Database schema (PostgreSQL 15+)

Apply in order. Use NUMERIC(20,0) for money fields.

-- 009_cash_accounts.sql
BEGIN;

CREATE TABLE bank_account (
  bank_acct_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  bank_id TEXT NOT NULL,                  -- e.g., ABA or bank code
  account_number_mask TEXT NOT NULL,      -- masked display only
  currency CHAR(3) NOT NULL DEFAULT 'USD',
  type TEXT NOT NULL CHECK (type IN ('operating','custodial_p_i','escrow','fees')),
  gl_cash_account gl_account NOT NULL DEFAULT 'cash',  -- ledger cash account used
  active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- ACH origination batches and entries
CREATE TYPE ach_service_class AS ENUM ('200','220','225');    -- credits/debits mixed, credits only, debits only
CREATE TYPE ach_txn_code AS ENUM ('22','27','32','37');       -- CCD/PPD std codes subset

CREATE TABLE ach_batch (
  ach_batch_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bank_acct_id UUID NOT NULL REFERENCES bank_account(bank_acct_id),
  service_class ach_service_class NOT NULL,
  company_id TEXT NOT NULL,            -- 10-char company id in NACHA
  company_name TEXT NOT NULL,
  effective_entry_date DATE NOT NULL,
  created_by TEXT NOT NULL,
  total_entries INTEGER NOT NULL DEFAULT 0,
  total_amount_minor NUMERIC(20,0) NOT NULL DEFAULT 0,
  status TEXT NOT NULL DEFAULT 'open' CHECK (status IN ('open','sealed','filed','settled','failed')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE TABLE ach_entry (
  ach_entry_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  ach_batch_id UUID NOT NULL REFERENCES ach_batch(ach_batch_id) ON DELETE CASCADE,
  loan_id UUID REFERENCES loan(loan_id),
  txn_code ach_txn_code NOT NULL,
  rdfi_routing TEXT NOT NULL,
  dda_account_mask TEXT NOT NULL,
  amount_minor NUMERIC(20,0) NOT NULL CHECK (amount_minor > 0),
  trace_number TEXT UNIQUE,                   -- assigned at file seal
  addenda TEXT,                               -- optional addenda, e.g., correlation id
  idempotency_key TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (idempotency_key)
);

-- ACH return notifications
CREATE TABLE ach_return (
  ach_return_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  ach_entry_id UUID NOT NULL REFERENCES ach_entry(ach_entry_id),
  return_code TEXT NOT NULL,             -- NACHA R01...Rxx
  return_date DATE NOT NULL,
  amount_minor NUMERIC(20,0) NOT NULL,
  addenda TEXT,
  processed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (ach_entry_id)
);

-- Bank statements ingestion
CREATE TYPE bank_stmt_format AS ENUM ('bai2','camt.053');

CREATE TABLE bank_statement_file (
  stmt_file_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bank_acct_id UUID NOT NULL REFERENCES bank_account(bank_acct_id),
  format bank_stmt_format NOT NULL,
  as_of_date DATE NOT NULL,
  raw_bytes BYTEA NOT NULL,
  file_hash CHAR(64) NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (bank_acct_id, as_of_date, file_hash)
);

CREATE TYPE bank_txn_type AS ENUM ('credit','debit','fee','return');

CREATE TABLE bank_txn (
  bank_txn_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  stmt_file_id UUID NOT NULL REFERENCES bank_statement_file(stmt_file_id) ON DELETE CASCADE,
  bank_acct_id UUID NOT NULL REFERENCES bank_account(bank_acct_id),
  posted_date DATE NOT NULL,
  value_date DATE,
  amount_minor NUMERIC(20,0) NOT NULL,
  type bank_txn_type NOT NULL,
  bank_ref TEXT,                          -- reference, trace, or remittance info
  description TEXT,
  matched BOOLEAN NOT NULL DEFAULT FALSE,
  matched_event_id UUID,                  -- ledger_event if matched
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Internal match surface
CREATE TABLE cash_match_candidate (
  candidate_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bank_txn_id UUID NOT NULL REFERENCES bank_txn(bank_txn_id) ON DELETE CASCADE,
  event_id UUID REFERENCES ledger_event(event_id),
  score INTEGER NOT NULL,
  reason TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Exceptions worklist
CREATE TYPE recon_status AS ENUM ('new','investigating','resolved','written_off');

CREATE TABLE recon_exception (
  recon_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bank_txn_id UUID NOT NULL REFERENCES bank_txn(bank_txn_id) ON DELETE CASCADE,
  variance_minor NUMERIC(20,0) NOT NULL,
  status recon_status NOT NULL DEFAULT 'new',
  assigned_to TEXT,
  note TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (bank_txn_id)
);

COMMIT;

2) File generators and parsers
2.1 NACHA file generation

Generator input:

export interface AchFileRequest {
  achBatchId: string;   // sealed batch
}


Precondition: ach_batch.status = 'sealed' and each entry has routing, masked DDA, amount, and idempotency_key.

Output: deterministic NACHA flat file bytes with:

File Header (priority 01), Batch Header, Entry Detail, optional Addenda, Batch Control, File Control.

Assign trace_number as ODFI_rt + 7-digit sequence. Persist on seal.

Compute hash totals per spec. All dates are the configured effective_entry_date.

Store file bytes on disk or object store. Also persist an outbox event ach.file.created.v1.

2.2 ACH returns ingestion

Accept NACHA Return file or bank portal CSV and normalize to:

interface AchReturnNormalized {
  traceNumber: string;
  returnCode: string;   // R01..Rxx
  returnDate: string;   // ISO date
  amountMinor: bigint;
  addenda?: string;
}


Join to ach_entry on trace_number. Insert into ach_return if not exists.

2.3 Bank statements ingestion

BAI2 and CAMT.053 parsers produce canonical transactions:

interface CanonicalBankTxn {
  bankAcctId: string;
  postedDate: string;
  valueDate?: string;
  amountMinor: bigint;      // positive for credits, negative for debits before normalization
  type: 'credit'|'debit'|'fee'|'return';
  bankRef?: string;
  description?: string;
}


Insert into bank_txn rows with normalized sign:

Credits become positive amount with type='credit'.

Debits become positive amount with type='debit'.

Returns map to type='return'.

Bank fees to type='fee'.

3) Matching engine
3.1 Candidate generation

For each bank_txn not matched:

Search internal ledger for ledger_event within a configurable window ±3 days whose lines include the bank account’s gl_cash_account with debit for credits and credit for debits. Use ledger_entry and sum to the event amount.

If bank_ref or description contains a known correlation_id, match directly with score 100.

Otherwise compute score as:

Amount equality → +60

Date within 1 day → +25, within 3 days → +10

Reference string fuzzy match of 0.8+ → +15

Same loan_id present in event memo → +10

Insert cash_match_candidate with the best 3 candidates.

3.2 Auto-match and post-match

If top candidate score ≥ 85:

Set bank_txn.matched=true and matched_event_id=that event.

Publish outbox cash.reconciled.v1.

Else create or update recon_exception with variance equal to bank amount minus event amount if there is a near match, or the whole bank amount if none.

3.3 Exceptions worklist actions

Worklist UI calls:

POST /recon/match body { bank_txn_id, event_id } → performs the match, sets matched=true, removes exception.

POST /recon/writeoff body { bank_txn_id, reason } → posts an adjusting event through ledger:

For bank fees not previously modeled: debit fee_expense account to be added to gl_account enum if not present, credit cash. Then mark matched.

POST /recon/note adds operator note.

4) Posting rules

ACH origination does not post until bank settlement. On settlement confirmation:

For ACH credits into operating account: debit cash, credit suspense or specific clearing account only if needed. Usually the payment event already debited cash. Do not double count. Use bank reconciliation to match rather than post a second event.

ACH returns:

Reverse the original payment allocations by creating a new balanced event with the exact opposite lines from the original posting.payment.v1 that referenced the gateway transaction. Use correlation_id = 'ach_return:' + ach_entry_id.

Assess NSF fee per fee_policy if configured:

Debit fees_receivable, credit fee_income or a specific nsf_fee_income account if you add it.

Publish outbox ach.return.received.v1 and payment.reversed.v1.

Bank fees:

Debit fee_expense (add to gl_account), credit cash. Correlate with bank_txn_id.

5) RabbitMQ topology

Exchanges:

cash.saga topic

cash.events topic

cash.dlq direct

Queues (quorum):

q.cash.ach.seal ← cash.saga:ach.seal.request.v1

q.cash.ach.returns ← cash.saga:ach.return.ingest.v1

q.cash.stmt.ingest ← cash.saga:stmt.ingest.v1

q.cash.reconcile ← cash.saga:reconcile.v1

q.cash.events.audit ← cash.events:cash.*|ach.*

q.cash.dlq ← cash.dlq:#

6) JSON Schemas

ach.file.created.v1, ach.return.received.v1, cash.reconciled.v1, payment.reversed.v1 under /shared/schemas/cash/. Each includes identifiers, amounts, and hashes if applicable. Validate on publish.

7) Metrics and SLAs

cash_stmt_ingested_total{format}

cash_auto_matched_total, cash_exceptions_total

ach_file_created_total, ach_returns_total{code}

SLO: Day plus one reconciliation - by 18:00 UTC the next business day, sum(unmatched credits - unmatched debits) = 0. Emit gauge cash_unexplained_variance_minor.

SLA timers for ACH returns:

On ach_return insert, start a timer NSF_RETRY_WINDOW_DAYS (config). Publish ach.return.received.v1 with an earliest retry time.

8) Acceptance tests

Ingest a BAI2 file and a matching set of internal events - auto-match clears all items, variance equals zero.

Ingest an ACH return R01 for a posted payment - ledger reversal event posted, NSF fee assessed if policy says so, and payment.reversed.v1 emitted.

Manual worklist match creates linkage and removes exception.

9) Legacy upgrade hit-list

Search and replace these patterns. Replace them with Phase-2 outbox publishers and Phase-6 services.

Direct file builders or ad-hoc CSV for NACHA:

grep for NACHA, File Header, Batch Header in app code. Replace with ach_batch + generator.

Any direct INSERT INTO ledger_entry to record bank fees or reversals:

grep for INSERT INTO ledger_entry and replace with postEvent(...).

Direct reconciliation spreadsheets or JSON dumps:

grep for reconcile and spreadsheet or XLSX usage. Replace with bank_txn, cash_match_candidate, and recon_exception.

Payment reversal code that sets negative payments rather than proper reversing events:

grep for negative payment, reversePayment, and replace with new reversal posting.

Definition of Done: day plus one reconciliation zero variance, returns processed with reversals, all events via outbox, and no direct ledger writes.

Phase 7 - Investor remittance and reporting
0) Scope and dependencies

Depends on Phases 1 to 3 and 6.

Goals: custodial P&I accounting, configurable investor waterfalls, scheduled remittances, investor exports, and reconciliations to GL.

1) Database schema
-- 010_investor_remittance.sql
BEGIN;

CREATE TABLE investor_contract (
  contract_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  investor_id UUID NOT NULL REFERENCES investor(investor_id),
  product_code TEXT NOT NULL REFERENCES product_policy(product_code),
  method TEXT NOT NULL CHECK (method IN ('scheduled_p_i','actual_cash','scheduled_p_i_with_interest_shortfall')),
  remittance_day SMALLINT NOT NULL CHECK (remittance_day BETWEEN 1 AND 31),
  cutoff_day SMALLINT NOT NULL CHECK (cutoff_day BETWEEN 1 AND 31),
  custodial_bank_acct_id UUID NOT NULL REFERENCES bank_account(bank_acct_id),
  servicer_fee_bps INTEGER NOT NULL DEFAULT 0,
  late_fee_split_bps INTEGER NOT NULL DEFAULT 0,  -- portion to investor
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Waterfall configuration
CREATE TABLE investor_waterfall_rule (
  rule_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_id UUID NOT NULL REFERENCES investor_contract(contract_id) ON DELETE CASCADE,
  rank SMALLINT NOT NULL,       -- order of application
  bucket TEXT NOT NULL CHECK (bucket IN ('interest','principal','late_fees','escrow','recoveries')),
  cap_minor NUMERIC(20,0),      -- optional cap for this bucket
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (contract_id, rank)
);

-- Remittance cycle
CREATE TYPE remit_status AS ENUM ('open','locked','file_generated','sent','settled','closed');

CREATE TABLE remittance_cycle (
  cycle_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_id UUID NOT NULL REFERENCES investor_contract(contract_id) ON DELETE CASCADE,
  period_start DATE NOT NULL,
  period_end DATE NOT NULL,
  status remit_status NOT NULL DEFAULT 'open',
  total_principal_minor NUMERIC(20,0) NOT NULL DEFAULT 0,
  total_interest_minor NUMERIC(20,0) NOT NULL DEFAULT 0,
  total_fees_minor NUMERIC(20,0) NOT NULL DEFAULT 0,
  servicer_fee_minor NUMERIC(20,0) NOT NULL DEFAULT 0,
  investor_due_minor NUMERIC(20,0) NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (contract_id, period_start, period_end)
);

-- Cycle line items (loan-level or pool-level)
CREATE TABLE remittance_item (
  item_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cycle_id UUID NOT NULL REFERENCES remittance_cycle(cycle_id) ON DELETE CASCADE,
  loan_id UUID REFERENCES loan(loan_id),
  principal_minor NUMERIC(20,0) NOT NULL DEFAULT 0,
  interest_minor NUMERIC(20,0) NOT NULL DEFAULT 0,
  fees_minor NUMERIC(20,0) NOT NULL DEFAULT 0,
  investor_share_minor NUMERIC(20,0) NOT NULL DEFAULT 0,
  servicer_fee_minor NUMERIC(20,0) NOT NULL DEFAULT 0
);

-- Export files registry
CREATE TABLE remittance_export (
  export_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  cycle_id UUID NOT NULL REFERENCES remittance_cycle(cycle_id) ON DELETE CASCADE,
  format TEXT NOT NULL CHECK (format IN ('csv','xml')),
  file_hash CHAR(64) NOT NULL,
  bytes BYTEA NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMIT;


Add GL accounts if missing:

investor_payable_principal

investor_payable_interest

servicer_fee_income

2) Aggregation and waterfall

Input set per cycle: all payment_posting.applied rows for loans under the contract’s product_code and investor_id, with effective_date between period_start and period_end and matched by the reconciled bank account used for custodial cash if applicable.

Aggregate by loan:

principal_collected, interest_collected, late_fees_collected.

Servicer fee:

servicer_fee_minor = round( interest_collected * servicer_fee_bps / 10000 ).

Investor share per rule sequence:

Apply interest to investor up to cap if any, less servicer fee.

Apply principal.

Apply late_fees split by late_fee_split_bps to investor; remainder to servicer fee or income.

Compute investor_share_minor and servicer_fee_minor per item and sum to cycle totals.

3) Posting rules on settlement

When cycle moves to settled:

Debit investor_payable_principal by total_principal_minor, credit cash from custodial account if paid out.

Debit investor_payable_interest by total_interest_minor - servicer_fee_minor_in_interest_share, credit cash.

Credit servicer_fee_income by servicer_fee_minor.

If you maintain investor payables earlier in the month, then settlement posting clears them to cash. If not, create payables here prior to cash movement.

All through postEvent, one balanced event per cycle, correlation_id='remit:'+cycle_id.

4) Remittance scheduling

For each investor_contract, create cycles:

period_start and period_end are bounded by cutoff_day.

remittance_day schedules settlement N business days after cutoff. Make holidays configurable later.

Job runs daily to open new cycles and close old ones when period_end passes. Lock cycle before export.

5) Exports

CSV columns minimal to start:

loan_id, period_start, period_end, principal_minor, interest_minor, fees_minor, investor_share_minor, servicer_fee_minor

XML stub mirrors CSV structure under <Remittance> root.

Files are deterministic and hashed. Insert into remittance_export, and publish remittance.file.generated.v1.

6) Events and queues

Exchanges:

remit.saga topic

remit.events topic

remit.dlq direct

Queues:

q.remit.aggregate ← remit.saga:cycle.aggregate.v1

q.remit.export ← remit.saga:cycle.export.v1

q.remit.settle ← remit.saga:cycle.settle.v1

q.remit.events.audit ← remit.events:remit.*

q.remit.dlq

Events:

remittance.cycle.created.v1

remittance.file.generated.v1

remittance.settled.v1

7) Reconciliation report

Create a report query that ties:

sum(remittance_item.investor_share_minor) and sum(remittance_item.servicer_fee_minor) to

GL balances movement from corresponding payables and income in ledger_entry over the same period.

Store a snapshot row in an internal table remittance_recon_snapshot with the signed differences. Threshold must be zero to pass acceptance.

8) Acceptance tests

Build a cycle with two loans, ensure waterfall splits are correct to the cent.

Generate CSV and XML, verify hashes are stable across runs.

Settlement posting is balanced and GL reconciliation report shows zero variance.

9) Legacy upgrade hit-list

Any code that pays investors directly from cash without creating investor payables:

grep for investor payout, pay investor, wire investor. Replace with cycle settlement posting.

Old “remittance” spreadsheets or ad hoc exports:

grep for remittance.csv, investor_export. Replace with remittance_export.

Direct fees netting in payment poster:

grep for servicerFee in payment code. Servicer fees must be computed in remittance, not at payment time.

Definition of Done: cycles created and settled on schedule, exports produced, GL reconciliation equals zero, and all legacy direct payouts removed.

Phase 8 - Borrower portal and servicer console
0) Scope and dependencies

Depends on Phases 1 to 4.

Deliver a secure borrower portal and an internal servicer console with RBAC, safe logging, and strict PII controls.

1) Security, auth, and PII

Identity provider: OIDC with PKCE. MFA via TOTP or SMS. Store only opaque subject identifiers.

Roles:

borrower

agent_read

agent_ops

supervisor

admin

RBAC matrix enforced server side. Do not trust client role claims without verification.

PII rules:

Mask SSN to last 4 always.

Mask account numbers except last 4.

Redact email and phone in logs.

Logging:

Structured logs. Never log request bodies for payment or messaging endpoints.

Use an allowlist of loggable fields. Add unit tests for log redaction.

2) API surface

All responses are JSON. Money values are strings of minor units.

Borrower APIs

GET /me/loans returns the borrower’s loans with masked PII.

GET /loans/:loanId/statement?period_start=&period_end= returns the Phase 4 document_artifact metadata and a signed URL to download.

POST /loans/:loanId/payments body { method, amount_minor, effective_date, source_token, idempotency_key }

Validates, hits the payment intake service, returns { payment_id }.

POST /loans/:loanId/autopay body { day_of_month, amount_minor?, method, source_token }

Creates an autopay mandate. Store only a tokenized payment method. No PAN or full account numbers.

GET /loans/:loanId/escrow/analysis/latest returns latest analysis summary.

GET /loans/:loanId/payoff_quote?good_through=YYYY-MM-DD

Returns { principal_minor, interest_minor, per_diem_minor, fees_minor, escrow_balance_minor, total_due_minor }. Per diem uses Phase 1 formula.

POST /me/messages body { subject, body } creates a secure message thread. Files go through virus scan.

Console APIs

GET /workqueues/recon returns recon_exception items with actions.

POST /workqueues/recon/:reconId/match request as Phase 6 worklist.

GET /workqueues/dlq lists DLQ messages by queue, supports requeue and purge actions with audit.

GET /collections/cases lists delinquency buckets and plans needing attention.

POST /escrow/analysis/:loanId/approve advances a pending analysis from Phase 3.

3) Frontend components

Use a single front-end stack with SSR and strict CSP. No inline scripts. Nonces on scripts. Subresource Integrity for CDN fonts if used, though Phase 4 prefers embedded fonts for PDFs only.

UI components must never render unmasked PII fields.

4) Payment UI flow

Always preauthorize via your gateway tokenization. Only store vault token.

Call borrower payments API which forwards to Phase 2 intake. Display idempotency outcome if duplicate.

Show applied allocation returned via payment.posted event on a live feed.

5) Statements and document download

Portal queries document_artifact and fetches via a signed URL. Use ETag equal to pdf_hash.

The server serves from DB or object store. Use Cache-Control: private.

6) Role based access control tests

Table of permissions:

borrower can only access their own loan resources and messages.

agent_read can view but not mutate payments or plans.

agent_ops can act on recon and collections but cannot modify templates or fee policies.

supervisor can approve escrow analyses and plans.

admin full control.

Implement as a middleware that checks both role and resource ownership. Return 403 with correlation id.

7) Observability and rate limiting

Per-user and per-IP rate limits on sensitive endpoints:

Payments: 10 per minute.

Payoff quotes: 30 per minute.

Messages: 20 per minute.

Metrics: ui_requests_total{route,role}, ui_denied_total{reason}, ui_pii_redactions_total.

8) Acceptance tests

RBAC integration: attempt to fetch another borrower’s statement as borrower returns 403.

No sensitive fields in logs: run test that triggers payment and then scan captured logs. Assert no PAN, no SSN, no full DDA present.

Payment happy path: tokenize source, call payment API, receive payment.received, then payment.posted updates balances displayed.

DLQ replay: push a message to a DLQ stub, replay from console, confirm consumer processes it exactly once.

9) Legacy upgrade hit-list

Direct DB reads from UI:

grep for pool.query("SELECT inside frontend or API controllers. Replace with service layer that enforces RBAC and masking.

Logging of req.body:

grep for console.log(req.body) or logger.info(req.body). Replace with filtered logging.

Old payment endpoints not using Phase 2 intake:

grep for routes handling /pay that call gateways directly. Replace with POST /loans/:loanId/payments that publishes payment.received.v1.

Any endpoint returning whole borrower records:

grep for SELECT * FROM borrower or return borrower. Replace with DTOs that mask PII.

Definition of Done: RBAC passes integration tests, no PII leaks in logs or client payloads, payments and statements work end-to-end via the pipeline, console workflows for recon, DLQ and collections are operational.

One-time repo tasks the team must complete

To ensure legacy code is truly retired, run these repo-wide tasks and fix every hit.

Replace direct ledger writes

grep -R "INSERT INTO ledger_entry" -n

Replace with postEvent(...) calls.

Remove direct publisher paths

grep -R "channel.publish(" -n outside the outbox dispatcher

Replace with outbox write and dispatcher publication.

Eliminate floating point money

grep -R "number\\s*[:=]" -n server/domain payments escrow

Replace with bigint minor units and conversion at edges.

Standardize event schemas

grep -R "payment.posted" -n for any hand-rolled payloads. Replace with the canonical JSON Schemas.

Kill legacy reconciliation scripts

grep -R "reconcile.*csv" -n and grep -R "XLSX" -n and remove in favor of Phase 6 tables and services.

Frontend PII scans

grep -R "ssn" -ni

grep -R "account_number" -ni

Replace with masked fields and redact in logs.