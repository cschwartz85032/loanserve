B01 – Queue Topology & Declaration (src/init-queues.ts, src/queues/topology.ts)

Define queue/exchange names in src/queues/topology.ts:

export const Exchanges = {
  COMMANDS: 'commands',         // direct exchange for commands
  EVENTS:   'loan.events',      // topic exchange for emitted events
};

export const Queues = {
  Import:        'import.command',
  Ocr:           'ocr.command',
  Datapoint:     'datapoint.command',
  Conflict:      'conflict.command',
  Disbursement:  'disbursement.command',
  Escrow:        'escrow.command',
  Ucdp:          'ucdp.command',
  Flood:         'flood.command',
  Hoi:           'hoi.command',
  Title:         'title.command',
};

export function retry(queue: string, suffix: string) {
  return `${queue}.retry.${suffix}`;
}
export function dlq(queue: string) {
  return `${queue}.dlq`;
}


Create an idempotent queue‑initialization script in src/init-queues.ts:

import amqp from 'amqplib';
import { Exchanges, Queues, retry, dlq } from './queues/topology';

const retryDelays = ['10s', '1m', '5m']; // define delays

async function assertQueue(channel: amqp.Channel, queue: string) {
  await channel.assertQueue(queue, { durable: true });
}

export async function initQueues() {
  const conn = await amqp.connect(process.env.RABBITMQ_URL!);
  const channel = await conn.createChannel();

  // Declare exchanges
  await channel.assertExchange(Exchanges.COMMANDS, 'direct', { durable: true });
  await channel.assertExchange(Exchanges.EVENTS,   'topic',  { durable: true });

  // For each queue, declare primary + retry + DLQ
  for (const queue of Object.values(Queues)) {
    await channel.assertQueue(queue, {
      durable: true,
      arguments: {
        'x-dead-letter-exchange': '',
        'x-dead-letter-routing-key': dlq(queue),
      },
    });
    // Bind primary queue to its exchange/routing key
    await channel.bindQueue(queue, Exchanges.COMMANDS, queue);

    // Declare retry queues with TTL
    for (const delay of retryDelays) {
      const [value, unit] = delay.match(/(\d+)(s|m)/)!.slice(1);
      const ttl = Number(value) * (unit === 's' ? 1000 : 60_000);
      const retryQueue = retry(queue, delay);
      await channel.assertQueue(retryQueue, {
        durable: true,
        arguments: {
          'x-dead-letter-exchange': '',
          'x-dead-letter-routing-key': queue,
          'x-message-ttl': ttl,
        },
      });
    }

    // Declare DLQ
    await channel.assertQueue(dlq(queue), { durable: true });
  }

  await channel.close();
  await conn.close();
}

if (require.main === module) {
  initQueues().catch((err) => {
    console.error(err);
    process.exit(1);
  });
}


Environment variable: Add RABBITMQ_URL to .env.example with a description (e.g. amqp://user:pass@host/vhost).

Deployment: Ensure initQueues() runs as part of your application startup or as a separate one‑time script.