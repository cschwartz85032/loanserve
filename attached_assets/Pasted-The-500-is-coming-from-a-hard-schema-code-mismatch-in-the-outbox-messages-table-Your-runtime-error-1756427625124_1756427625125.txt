The 500 is coming from a hard schema/code mismatch in the outbox_messages table.

Your runtime error shows:

error: column "published_at" of relation "outbox_messages" does not exist
 at OutboxService.createMessage (...)
 at /server/routes/crm.ts:854


I inspected the code you uploaded and the DB dump:

Code (schema.ts / outbox.ts) expects columns:

publishedAt, attemptCount, lastError, nextRetryAt, plus createdAt

Database (database_schema.sql) actually has:

status, retry_count, processed_at, error_message, and created_at

That drift causes Postgres to reject the INSERT generated by Drizzle against the new shape.

Immediate fix (no code changes)

Run this SQL migration now to add the missing columns that the code expects, while leaving legacy columns in place so nothing else breaks. Then cut the CRM to respond 202 Accepted instead of waiting for the send to complete.

-- 1) Add columns required by code
ALTER TABLE public.outbox_messages
  ADD COLUMN IF NOT EXISTS published_at timestamptz,
  ADD COLUMN IF NOT EXISTS attempt_count integer NOT NULL DEFAULT 0,
  ADD COLUMN IF NOT EXISTS last_error text,
  ADD COLUMN IF NOT EXISTS next_retry_at timestamptz;

-- 2) Optional: keep legacy columns for now to avoid breaking anything:
-- status, retry_count, processed_at, error_message remain in place

-- 3) Safety indexes for dispatcher scans
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE schemaname='public' AND indexname='idx_outbox_unpublished'
  ) THEN
    CREATE INDEX idx_outbox_unpublished
      ON public.outbox_messages ((published_at IS NULL), created_at);
  END IF;
END $$;


Why this fixes the 500: your Drizzle model (and OutboxService) will stop referencing non-existent columns; inserts and selects will succeed again.

Short follow-ups (same deploy)

Make the CRM email endpoint fire-and-queue, not fire-and-send.
In crm.ts, return 202 Accepted after writing the outbox row; do not try to render or send the email inline. The worker/consumer does that.

Outbox dispatcher running:
Ensure OutboxDispatcher is actually running (process or worker) and reading unpublished rows where published_at IS NULL, not status='pending'.

Audit trail on the request path (Phase 9):
Right after the outbox insert, write a compliance audit record:

await complianceAudit.log({
  actorId: req.user.id,
  objectType: 'loan',
  objectId: loanId,
  action: COMPLIANCE_EVENTS.CRM.EMAIL_REQUESTED,  // add to your taxonomy
  oldValue: null,
  newValue: JSON.stringify({
    to, cc, bcc, subject, docIds: docIdArray ?? [], attachmentCount: attachments.length
  }),
  correlationId: req.correlationId
});


You already have auditService.ts and the compliance taxonomy; make sure this specific action exists.

Hardening plan to remove legacy shape (after traffic is healthy)

Once messages are flowing:

Cut code to canonical columns only
Confirm all code paths (dispatcher + publisher) use publishedAt, attemptCount, lastError, nextRetryAt.
Search and remove any usage of status, retry_count, processed_at, error_message.

Backfill & delete legacy columns (one release later)

-- Optional backfill if you want historical parity:
UPDATE public.outbox_messages
SET published_at = processed_at
WHERE published_at IS NULL AND processed_at IS NOT NULL;

ALTER TABLE public.outbox_messages
  DROP COLUMN IF EXISTS status,
  DROP COLUMN IF EXISTS retry_count,
  DROP COLUMN IF EXISTS processed_at,
  DROP COLUMN IF EXISTS error_message;


Dispatcher logic = new shape

Poll: WHERE published_at IS NULL ordered by created_at ASC.

On success: published_at = now(), last_error = NULL.

On failure: increment attempt_count, set last_error, compute next_retry_at (exponential backoff).

Add migration check in startup
At service boot, run a lightweight probe:

SELECT column_name FROM information_schema.columns WHERE table_name='outbox_messages'

If required columns are missing, log a red-level error and expose /healthz as unhealthy. This prevents silent drift.

Finish the CRM email pipeline alignment (Phase 4–5 and 9)

Your current crm.ts still calls CRMNotificationService directly and the notification-service.ts sends immediately via SendGrid. That defeats the outbox and makes the request path fragile.

Replace the direct send with an outbox event and a consumer:

In crm.ts (request path):

await outboxService.createMessage({
  aggregateType: 'crm',
  aggregateId: String(loanId),
  eventType: 'crm.email.requested.v1',
  payload: {
    to, cc, bcc, subject, variables: {...}, // include any template vars you use
    attachments: attachments.map(a => ({ filename: a.filename, content: a.content, type: a.type })),
    userId: req.user.id
  }
});
return res.status(202).json({ queued: true });


crm-email-consumer.ts (worker path):

Consume crm.email.requested.v1.

Call CRMNotificationService to render + send.

On success: publish crm.email.sent.v1 and write complianceAudit entry CRM.EMAIL_SENT.

On failure: publish crm.email.failed.v1 and write CRM.EMAIL_FAILED audit.

notification-service.ts changes:

Ensure it does not send directly from the HTTP route.

Keep SendGrid details here, but only invoked by the consumer/worker.

When a document is generated, store artifact hash and link.

Phase 9 guarantees:

Every CRM mutation writes to audit_logs with correlation_id.

Email request, success, and failure all produce distinct audit rows.

Why the error pointed at /routes/crm.ts:854

You recently added (or partially added) an outbox call on the email path; the first write to outbox hit the schema drift and failed at insert. Fixing the DDL above unblocks that immediately.

Quick verification checklist (run after the migration)

Insert into outbox_messages succeeds; no 500 on the route.

Dispatcher logs show polls against published_at IS NULL, then publish-confirms, then published_at set.

Consumer receives crm.email.requested.v1 and invokes notification-service.

SendGrid sends successfully; artifact stored.

audit_logs contains both EMAIL_REQUESTED and EMAIL_SENT (or EMAIL_FAILED) with your request’s correlation ID.

CRM endpoint returns 202 { queued: true } and never 500s on happy paths.