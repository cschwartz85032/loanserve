Step 15 — Monthly Servicing Cycle, Statements & Escrow Disbursements (complete, paste-ready) so engineering only codes and runs. This step delivers:

Monthly servicing cycle engine (due generation, delinquency aging, late fees, statements).

Escrow analysis → vendor bills → disbursement requests (ACH/check/webhook stub).

GL postings for fees and disbursements.

APIs to view cycles, statements, vendor bills, and disbursements.

Workers/queues that run daily and on due-dates; cronless design via RabbitMQ timer pattern.

PDF statement generator (watermarked, itemized, remittance slip).

Acceptance tests + “must not change” guardrails.

No decisions left—just paste and wire.

0) Environment

.env

# Cycle scheduler
SVC_CYCLE_TICK_CRON=*/5 * * * *         # external scheduler publishes tick; worker is idempotent daily
SVC_BUSINESS_TZ=America/New_York

# Late fees & delinquency
LATE_FEE_PCT_OF_PI=0.05                  # 5% of contractual P&I amount
LATE_FEE_GRACE_DAYS=15                   # overrides per-loan grace if set
DELINQ_BUCKETS=0,30,60,90,120            # days thresholds

# Statements
STMT_PDF_HEADER=LoanServe • Monthly Statement
STMT_PDF_WATERMARK=LoanServe
STMT_S3_PREFIX=statements
STMT_CONTACT_EMAIL=servicing@loanserve.io
STMT_CONTACT_PHONE=+1-555-555-1212
STMT_RETURN_ADDRESS="LoanServe, PO Box 123, Phoenix, AZ 85032"

# Escrow analysis defaults
ESCROW_ANALYSIS_INFLATION_PCT=0.03       # used also in Step 14; repeat here for cycle
ESCROW_SHORTAGE_MIN_PAY=100.00           # minimum shortage collection if any

# Disbursements (ACH/check/webhook placeholders)
DISB_DEFAULT_METHOD=ACH                  # ACH | CHECK | WEBHOOK
DISB_WEBHOOK_URL=https://example.com/payments
DISB_WEBHOOK_SECRET=

# GL accounts for fees & escrow payouts
GL_CASH_ACCT=1000
GL_ESCROW_LIABILITY_ACCT=2100
GL_LATE_FEE_INCOME_ACCT=4100

1) Database — cycles, statements, vendor bills, disbursements, fees

migrations/019_cycle_statements_disbursements.sql

BEGIN;

-- 1) Cycle runs (idempotency for daily engine)
CREATE TABLE IF NOT EXISTS svc_cycle_runs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  as_of_date date NOT NULL,
  status text NOT NULL CHECK (status IN ('started','completed','failed')) DEFAULT 'started',
  metrics jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  completed_at timestamptz NULL,
  UNIQUE (tenant_id, as_of_date)
);

-- 2) Monthly statements
CREATE TABLE IF NOT EXISTS svc_statements (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  loan_id uuid NOT NULL REFERENCES loan_candidates(id) ON DELETE CASCADE,
  statement_date date NOT NULL,
  cycle_label text NOT NULL,                -- e.g. 2025-10
  file_uri text NOT NULL,
  file_sha256 text NOT NULL,
  summary jsonb NOT NULL,                   -- balances, due amounts, delinquency, escrow, shortage etc.
  created_at timestamptz NOT NULL DEFAULT now(),
  UNIQUE (loan_id, cycle_label)
);

-- 3) Vendor bills (escrow payees)
CREATE TABLE IF NOT EXISTS svc_vendor_bills (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  loan_id uuid NOT NULL REFERENCES loan_candidates(id) ON DELETE CASCADE,
  vendor_id uuid NOT NULL,
  bucket text NOT NULL CHECK (bucket IN ('TAX','HOI','FLOOD','HOA','OTHER')),
  due_date date NOT NULL,
  amount numeric(18,2) NOT NULL,
  status text NOT NULL CHECK (status IN ('Queued','Scheduled','Paid','Failed','Cancelled')) DEFAULT 'Queued',
  created_at timestamptz NOT NULL DEFAULT now()
);

-- 4) Disbursements (outgoing payments)
CREATE TABLE IF NOT EXISTS svc_disbursements (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL,
  loan_id uuid NOT NULL REFERENCES loan_candidates(id) ON DELETE CASCADE,
  vendor_id uuid NULL,                      -- escrow payees have a vendor; others may not
  bill_id uuid NULL,                        -- optional link to vendor bill
  method text NOT NULL CHECK (method IN ('ACH','CHECK','WEBHOOK')),
  scheduled_date date NOT NULL,
  amount numeric(18,2) NOT NULL,
  currency text NOT NULL DEFAULT 'USD',
  status text NOT NULL CHECK (status IN ('Requested','Sent','Settled','Failed','Cancelled')) DEFAULT 'Requested',
  reference text NULL,                      -- ACH trace / check #
  meta jsonb NOT NULL DEFAULT '{}'::jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  sent_at timestamptz NULL,
  settled_at timestamptz NULL
);

-- 5) Fees — record late fee assessments as txns with type FEE
ALTER TABLE svc_txns
  ADD COLUMN IF NOT EXISTS fee_code text NULL;  -- e.g., LATE

CREATE INDEX IF NOT EXISTS idx_stmt_loan ON svc_statements(tenant_id, loan_id, statement_date);
CREATE INDEX IF NOT EXISTS idx_bills_loan ON svc_vendor_bills(tenant_id, loan_id, due_date);
CREATE INDEX IF NOT EXISTS idx_disb_loan ON svc_disbursements(tenant_id, loan_id, scheduled_date);

COMMIT;

2) Delinquency & fee policy helpers

src/servicing/policy.ts

import dayjs from "dayjs"; import tz from "dayjs/plugin/timezone"; import utc from "dayjs/plugin/utc";
dayjs.extend(utc); dayjs.extend(tz);
const Z = process.env.SVC_BUSINESS_TZ || "America/New_York";

export function daysPastDue(dueISO:string, paid:boolean, paidAt?:string|null, asOfISO?:string){
  const asOf = dayjs.tz(asOfISO || dayjs().format("YYYY-MM-DD"), Z);
  const due = dayjs.tz(dueISO, Z);
  if (paid && paidAt) {
    const p = dayjs.tz(paidAt, Z);
    return Math.max(0, p.diff(due, "day"));
  }
  return Math.max(0, asOf.diff(due, "day"));
}

export function delinquencyBucket(dp:number): string {
  const buckets = (process.env.DELINQ_BUCKETS || "0,30,60,90,120").split(",").map(n=>Number(n.trim())).sort((a,b)=>a-b);
  let label = `${buckets[0]}+`;
  for (let i=buckets.length-1;i>=0;i--) if (dp >= buckets[i]) { label = `${buckets[i]}+`; break; }
  return label;
}

export function lateFee(pi:number): number {
  const pct = Number(process.env.LATE_FEE_PCT_OF_PI || "0.05");
  return round2(pi * pct);
}

export function graceDays(loanGrace?:number): number {
  if (loanGrace && loanGrace > 0) return loanGrace;
  return Number(process.env.LATE_FEE_GRACE_DAYS || "15");
}

function round2(n:number){ return Math.round((n+Number.EPSILON)*100)/100; }

3) Statement PDF generator

src/servicing/statementPdf.ts

import PDFDocument from "pdfkit";
import { sha256Buf } from "../utils/hash";

export async function renderStatementPdf(input:{
  header:string, watermark:string,
  account:any, schedule:any[], asOf:string,
  priorBalance:number, currentDue:{ principal:number, interest:number, escrow:number, fees:number, total:number },
  delinquency:{ dpd:number, bucket:string },
  escrow:{ buckets:Record<string,number>, balance:number, shortage:number },
  remitTo:{ email:string, phone:string, address:string }
}) {
  const doc = new PDFDocument({ size:"LETTER", margin:50 });
  const buffers:Buffer[] = [];
  doc.on("data", (b)=>buffers.push(b));

  // Header & watermark
  doc.fontSize(18).text(input.header, { align:"center" }).moveDown(0.5);
  addWatermark(doc, input.watermark);

  // Account header
  doc.fontSize(12);
  doc.text(`Statement Date: ${input.asOf}`);
  doc.text(`Loan ID: ${input.account.loan_id}`);
  doc.text(`Status: ${input.account.state}`);
  doc.text(`Due (next): ${input.schedule[0]?.due_date || "(n/a)"}`).moveDown(0.5);

  // Amounts
  doc.fontSize(14).text("Amount Due", { underline:true }).moveDown(0.2);
  const d = input.currentDue;
  doc.fontSize(12).text(`Principal: $${fmt(d.principal)}   Interest: $${fmt(d.interest)}   Escrow: $${fmt(d.escrow)}   Fees: $${fmt(d.fees)}`);
  doc.fontSize(14).text(`Total Due: $${fmt(d.total)}`).moveDown(0.5);

  // Delinquency
  doc.fontSize(12).text(`Days Past Due: ${input.delinquency.dpd} (bucket ${input.delinquency.bucket})`).moveDown(0.5);

  // Escrow
  doc.fontSize(14).text("Escrow", { underline:true }).moveDown(0.2);
  doc.fontSize(12).text(`Balance: $${fmt(input.escrow.balance)}   Shortage: $${fmt(input.escrow.shortage)}`);
  const eb = input.escrow.buckets;
  doc.text(`Monthly Accruals — TAX: $${fmt(eb.TAX||0)} HOI: $${fmt(eb.HOI||0)} FLOOD: $${fmt(eb.FLOOD||0)} HOA: $${fmt(eb.HOA||0)}`).moveDown(0.5);

  // Schedule teaser (3 rows)
  doc.fontSize(14).text("Upcoming Schedule", { underline:true }).moveDown(0.2);
  doc.fontSize(12);
  input.schedule.slice(0,3).forEach(r=>{
    doc.text(`${r.installment_no}. ${r.due_date}  P: $${fmt(r.principal_due)}  I: $${fmt(r.interest_due)}  Esc: $${fmt(r.escrow_due)}  Total: $${fmt(r.total_due)}`);
  });
  doc.moveDown(0.5);

  // Remittance box
  doc.fontSize(14).text("How to Pay", { underline:true }).moveDown(0.2);
  doc.fontSize(12).text(`Email: ${input.remitTo.email}  Phone: ${input.remitTo.phone}`);
  doc.text(`Mail: ${input.remitTo.address}`);

  doc.end();
  const pdf = await new Promise<Buffer>((resolve)=> doc.on("end", ()=> resolve(Buffer.concat(buffers))));
  return { pdf, sha256: sha256Buf(pdf) };
}

function addWatermark(doc:PDFKit.PDFDocument, text:string){
  if (!text) return;
  const { width, height } = doc.page;
  doc.save(); doc.fillColor("#dddddd").fontSize(40)
    .rotate(-30, { origin:[width/2,height/2] }).opacity(0.2)
    .text(text, width/2-200, height/2-50).opacity(1).rotate(30, { origin:[width/2,height/2] }).restore();
}
function fmt(n:number){ return n.toFixed(2); }

4) Cycle Engine — daily tick

/mnt/data/init-queues.ts (add)

await ch.assertExchange("svc.cycle","topic",{durable:true});
const bindC = async (q:string,rk:string)=>{
  await ch.assertQueue(q,{durable:true,arguments:{
    "x-dead-letter-exchange":"dlx",
    "x-dead-letter-routing-key":`${q}.dlq`
  }});
  await ch.bindQueue(q,"svc.cycle",rk);
  await ch.assertQueue(`${q}.retry`,{durable:true,arguments:{
    "x-dead-letter-exchange":"svc.cycle",
    "x-dead-letter-routing-key":rk,
    "x-message-ttl":15000
  }});
  await ch.assertQueue(`${q}.dlq`,{durable:true});
  await ch.bindQueue(`${q}.dlq`,"dlx",`${q}.dlq`);
};
await bindC("svc.cycle.tick.q","tick");
await bindC("svc.cycle.completed.q","completed");


src/servicing/cycle.ts

import { Pool } from "pg";
import dayjs from "dayjs"; import tz from "dayjs/plugin/timezone"; import utc from "dayjs/plugin/utc";
import { graceDays, daysPastDue, delinquencyBucket, lateFee } from "./policy";
import { renderStatementPdf } from "./statementPdf";
import { putBytes } from "../utils/storage";
const pool = new Pool({ connectionString: process.env.DB_URL });
dayjs.extend(utc); dayjs.extend(tz);
const Z = process.env.SVC_BUSINESS_TZ || "America/New_York";

export async function runDailyCycle(tenantId:string, asOfISO?:string){
  const asOf = dayjs.tz(asOfISO || dayjs().format("YYYY-MM-DD"), Z).format("YYYY-MM-DD");
  const client = await pool.connect();
  try {
    await client.query(`SET LOCAL app.tenant_id = $1`, [tenantId]);
    // idempotency
    const exist = await client.query(`SELECT 1 FROM svc_cycle_runs WHERE tenant_id=$1 AND as_of_date=$2`, [tenantId, asOf]);
    if (exist.rowCount) return { ok:true, skipped:true };
    await client.query(`INSERT INTO svc_cycle_runs (tenant_id, as_of_date, status) VALUES ($1,$2,'started')`, [tenantId, asOf]);

    // fetch Active accounts
    const acc = await client.query(`SELECT * FROM svc_accounts WHERE state='Active'`);
    let issued = 0, lateFees = 0, billsQueued = 0;

    for (const a of acc.rows) {
      const loanId = a.loan_id;

      // 1) Determine current installment due as of today (the smallest unpaid schedule row)
      const sched = await client.query(`
        SELECT * FROM svc_schedule WHERE loan_id=$1 AND paid=false ORDER BY installment_no ASC LIMIT 1
      `, [loanId]);
      const row = sched.rows[0];
      if (!row) continue;

      // 2) Delinquency and late fee
      const dpd = daysPastDue(row.due_date, row.paid, row.paid_at);
      const bucket = delinquencyBucket(dpd);
      const grace = graceDays(a.grace_days);
      let assessedLate = false;

      if (dpd > grace) {
        // Has a late fee txn already been posted for this installment?
        const feeExists = await client.query(`
          SELECT 1 FROM svc_txns WHERE loan_id=$1 AND type='FEE' AND fee_code='LATE' AND ref->>'installment_no' = $2::text
        `, [loanId, String(row.installment_no)]);
        if (!feeExists.rowCount) {
          const fee = lateFee(Number(a.pmt_principal_interest));
          await client.query(`
            INSERT INTO svc_txns (tenant_id, loan_id, type, amount, alloc_fees, fee_code, memo, ref)
            VALUES ($1,$2,'FEE',$3, $3, 'LATE','Late fee after grace', jsonb_build_object('installment_no',$4,'due_date',$5))
          `, [tenantId, loanId, fee, row.installment_no, row.due_date]);
          // GL: Credit Late Fee Income, Debit Cash (or A/R Fees). For simplicity, cash acct here.
          await client.query(`
            INSERT INTO gl_entries (tenant_id, loan_id, debit_acct, credit_acct, amount, memo)
            VALUES ($1,$2,$3,$4,$5,'Late fee assessment')
          `, [tenantId, loanId, Number(process.env.GL_CASH_ACCT||"1000"), Number(process.env.GL_LATE_FEE_INCOME_ACCT||"4100"), fee]);
          assessedLate = true; lateFees++;
        }
      }

      // 3) Statement generation on due date (or the first calendar day of month—pick due date rule)
      const isDueToday = row.due_date === asOf;
      if (isDueToday) {
        // Compute current due (use schedule row + any accrued fees on account)
        const feesRow = await client.query(`
          SELECT COALESCE(SUM(alloc_fees),0) AS fees FROM svc_txns WHERE loan_id=$1 AND type IN ('FEE') AND ts::date <= $2::date
        `, [loanId, asOf]);
        const due = {
          principal: Number(row.principal_due),
          interest: Number(row.interest_due),
          escrow: Number(row.escrow_due),
          fees: Number(feesRow.rows[0].fees || 0)
        };
        const total = round2(due.principal + due.interest + due.escrow + due.fees);

        // Escrow status
        const escSub = await client.query(`SELECT bucket, monthly_accrual, balance FROM svc_escrow_sub WHERE loan_id=$1`, [loanId]);
        const buckets:Record<string,number> = {}; let escBal = 0;
        for (const e of escSub.rows) { buckets[e.bucket] = Number(e.monthly_accrual); escBal += Number(e.balance); }

        // Simple shortage: ensure 2-month cushion
        const cushion = (Number(process.env.ESCROW_CUSHION_MONTHS||"2")) * (buckets.TAX||0 + buckets.HOI||0 + buckets.FLOOD||0 + buckets.HOA||0);
        const shortage = Math.max(0, round2(cushion - escBal));
        const shortageMin = Number(process.env.ESCROW_SHORTAGE_MIN_PAY || "100");
        const shortageCollectThisCycle = shortage > 0 ? Math.max(shortageMin, Math.ceil(shortage/12)) : 0;
        const escrowBalance = escBal;

        // Statement PDF
        const stmt = await renderStatementPdf({
          header: process.env.STMT_PDF_HEADER || "LoanServe • Monthly Statement",
          watermark: process.env.STMT_PDF_WATERMARK || "",
          account: a,
          schedule: [row],
          asOf,
          priorBalance: row.principal_balance_after + Number(row.escrow_due || 0),
          currentDue: { ...due, total },
          delinquency: { dpd, bucket },
          escrow: { buckets, balance: escrowBalance, shortage, },
          remitTo: { email: process.env.STMT_CONTACT_EMAIL || "", phone: process.env.STMT_CONTACT_PHONE || "", address: process.env.STMT_RETURN_ADDRESS || "" }
        });
        const key = `${process.env.S3_PREFIX||"tenants"}/${tenantId}/loans/${loanId}/${process.env.STMT_S3_PREFIX||"statements"}/STMT_${a.loan_id}_${asOf}.pdf`;
        const uri = await putBytes(key, stmt.pdf, "application/pdf");
        await client.query(`
          INSERT INTO svc_statements (tenant_id, loan_id, statement_date, cycle_label, file_uri, file_sha256, summary)
          VALUES ($1,$2,$3,$4,$5,$6,$7)
        `, [tenantId, loanId, asOf, asOf.slice(0,7), uri, stmt.sha256, JSON.stringify({
          due, total, delinquency:{dpd,bucket}, escrow:{balance:escrowBalance, shortage, buckets}, shortageCollectThisCycle
        })]);
        issued++;
      }

      // 4) Escrow bills: if due within next 30 days and not queued, create bill & disbursement
      const bills = await client.query(`
        SELECT v.id as vendor_id, v.type, v.name
          FROM svc_vendors v WHERE v.loan_id=$1 AND v.type IN ('TAX','HOI','FLOOD','HOA')
      `, [loanId]);
      const horizon = dayjs.tz(asOf, Z).add(30,"day").format("YYYY-MM-DD");
      for (const b of bills.rows) {
        // Heuristic: next due on 15th of next month for demo; in prod, derive from docs or vendor APIs
        const impliedDue = dayjs.tz(asOf,Z).add(1,"month").date(15).format("YYYY-MM-DD");
        // skip if already queued for that vendor and due date
        const existBill = await client.query(`SELECT 1 FROM svc_vendor_bills WHERE loan_id=$1 AND vendor_id=$2 AND due_date=$3`, [loanId, b.vendor_id, impliedDue]);
        if (existBill.rowCount) continue;

        const accrual = buckets[b.type] || 0;      // monthly bucket as estimate
        const amount = Math.max(50, round2(accrual*12)); // simple annualized estimate with floor
        // escrow sufficiency check
        const escBal = escrowBalance;
        const scheduled = (escBal >= amount) ? 'Scheduled' : 'Queued';  // if insufficient, stay queued
        await client.query(`
          INSERT INTO svc_vendor_bills (tenant_id, loan_id, vendor_id, bucket, due_date, amount, status)
          VALUES ($1,$2,$3,$4,$5,$6,$7)
        `, [tenantId, loanId, b.vendor_id, b.type, impliedDue, amount, scheduled]);
        if (scheduled === 'Scheduled') {
          const method = (process.env.DISB_DEFAULT_METHOD || 'ACH') as 'ACH'|'CHECK'|'WEBHOOK';
          await client.query(`
            INSERT INTO svc_disbursements (tenant_id, loan_id, vendor_id, bill_id, method, scheduled_date, amount, status, meta)
            VALUES ($1,$2,$3,(SELECT id FROM svc_vendor_bills WHERE loan_id=$2 AND vendor_id=$3 AND due_date=$4 LIMIT 1),$5,$4,$6,'Requested','{}')
          `, [tenantId, loanId, b.vendor_id, impliedDue, method, amount]);
          billsQueued++;
        }
      }
    }

    await client.query(`UPDATE svc_cycle_runs SET status='completed', completed_at=now(), metrics=$3 WHERE tenant_id=$1 AND as_of_date=$2`,
      [tenantId, asOf, JSON.stringify({ issued, lateFees, billsQueued })]);

    return { ok:true, issued, lateFees, billsQueued };
  } catch (e:any) {
    await pool.query(`UPDATE svc_cycle_runs SET status='failed', completed_at=now(), metrics=$3 WHERE tenant_id=$1 AND as_of_date=$2`,
      [tenantId, asOf, JSON.stringify({ error:String(e) })]).catch(()=>{});
    throw e;
  } finally { client.release(); }
}

function round2(n:number){ return Math.round((n+Number.EPSILON)*100)/100; }

5) Cycle Worker — tick & complete

src/workers/ServicingCycleWorker.ts

import { mq } from "../topology";
import { runDailyCycle } from "../servicing/cycle";

export async function startServicingCycleWorker(){
  // cron scheduler should publish: { tenantId, asOf? } to rk 'tick'
  await mq.consume("svc.cycle.tick.q", async (msg:any, ch:any)=>{
    const { tenantId, asOf } = JSON.parse(msg.content.toString());
    try {
      const r = await runDailyCycle(tenantId, asOf);
      await mq.publish("svc.cycle","completed",{ tenantId, asOf, ...r });
      ch.ack(msg);
    } catch (e:any) {
      await mq.publish("svc.cycle","completed",{ tenantId, asOf, error:String(e) });
      ch.nack(msg, false, false);
    }
  });
}


src/service.ts (add)

import { startServicingCycleWorker } from "./workers/ServicingCycleWorker";
await startServicingCycleWorker();


Triggering: Use your infra scheduler (or a tiny cron container) to publish a JSON message daily to svc.cycle exchange with rk tick, per tenant:

{ "tenantId": "<TENANT-UUID>", "asOf": "2025-10-01" }

6) Disbursement push (to your existing disbursement service)

/mnt/data/init-queues.ts (ensure these exist)
(You already have disbursement-service.ts and disbursement-consumer.ts. We bridge to them.)

await ch.assertExchange("svc.disb","topic",{durable:true});
const bindD = async (q:string,rk:string)=>{
  await ch.assertQueue(q,{durable:true,arguments:{
    "x-dead-letter-exchange":"dlx",
    "x-dead-letter-routing-key":`${q}.dlq`
  }});
  await ch.bindQueue(q,"svc.disb",rk);
  await ch.assertQueue(`${q}.retry`,{durable:true,arguments:{
    "x-dead-letter-exchange":"svc.disb",
    "x-dead-letter-routing-key":rk,
    "x-message-ttl":15000
  }});
  await ch.assertQueue(`${q}.dlq`,{durable:true});
  await ch.bindQueue(`${q}.dlq`,"dlx",`${q}.dlq`);
};
await bindD("svc.disb.request.q","request");
await bindD("svc.disb.completed.q","completed");


src/servicing/disbursements.ts

import { Pool } from "pg";
const pool = new Pool({ connectionString: process.env.DB_URL });

export async function queueDueDisbursements(tenantId:string, asOfISO:string){
  const client = await pool.connect();
  try {
    await client.query(`SET LOCAL app.tenant_id = $1`, [tenantId]);
    const rows = await client.query(`
      SELECT d.id, d.loan_id, d.vendor_id, d.bill_id, d.amount, d.method
      FROM svc_disbursements d
      WHERE d.scheduled_date <= $1::date AND d.status='Requested'
    `, [asOfISO]);
    return rows.rows;
  } finally { client.release(); }
}


src/workers/DisbursementBridgeWorker.ts

import { mq } from "../topology";
import { queueDueDisbursements } from "../servicing/disbursements";

export async function startDisbursementBridgeWorker(){
  // also kick when cycle completes (same day) to push due disbursements
  await mq.consume("svc.cycle.completed.q", async (msg:any, ch:any)=>{
    const { tenantId, asOf, error } = JSON.parse(msg.content.toString());
    try {
      if (!error) {
        const due = await queueDueDisbursements(tenantId, asOf);
        for (const d of due) {
          await mq.publish("svc.disb","request",{
            tenantId, disbursementId: d.id, loanId: d.loan_id, vendorId: d.vendor_id,
            billId: d.bill_id, method: d.method, amount: d.amount
          });
        }
      }
      ch.ack(msg);
    } catch (e:any) {
      ch.nack(msg, false, false);
    }
  });
}


src/service.ts (add)

import { startDisbursementBridgeWorker } from "./workers/DisbursementBridgeWorker";
await startDisbursementBridgeWorker();


Your existing disbursement-consumer should pick up svc.disb#request and execute ACH/CHECK/WEBHOOK. When it completes, it should publish svc.disb#completed. Add the state update:

src/workers/DisbursementStatusWorker.ts

import { mq } from "../topology";
import { Pool } from "pg";
const pool = new Pool({ connectionString: process.env.DB_URL });

export async function startDisbursementStatusWorker(){
  await mq.consume("svc.disb.completed.q", async (msg:any, ch:any)=>{
    const { tenantId, disbursementId, status, reference } = JSON.parse(msg.content.toString());
    const c = await pool.connect();
    try {
      await c.query(`SET LOCAL app.tenant_id=$1`, [tenantId]);
      await c.query(`UPDATE svc_disbursements SET status=$2, reference=$3, sent_at=CASE WHEN $2='Sent' THEN now() ELSE sent_at END, settled_at=CASE WHEN $2='Settled' THEN now() ELSE settled_at END WHERE id=$1`,
        [disbursementId, status, reference || null]);
      // Escrow GL on settlement
      if (status === 'Settled') {
        const row = await c.query(`SELECT loan_id, amount FROM svc_disbursements WHERE id=$1`, [disbursementId]);
        const loanId = row.rows[0].loan_id; const amt = Number(row.rows[0].amount);
        await c.query(`
          INSERT INTO gl_entries (tenant_id, loan_id, debit_acct, credit_acct, amount, memo)
          VALUES ($1,$2,$3,$4,$5,'Escrow disbursement')
        `, [tenantId, loanId, Number(process.env.GL_ESCROW_LIABILITY_ACCT||"2100"), Number(process.env.GL_CASH_ACCT||"1000"), amt]);
      }
      ch.ack(msg);
    } catch (e) {
      ch.nack(msg, false, false);
    } finally { c.release(); }
  });
}


src/service.ts (add)

import { startDisbursementStatusWorker } from "./workers/DisbursementStatusWorker";
await startDisbursementStatusWorker();

7) Routes — cycles, statements, bills, disbursements

src/routes/cycle.routes.ts

import { Router } from "express";
import { Pool } from "pg";
export const cycleRouter = Router();
const pool = new Pool({ connectionString: process.env.DB_URL });

cycleRouter.post("/servicing/cycle/tick", async (req:any,res)=>{
  // Admin endpoint to manually trigger today's tick
  await req.mq.publish("svc.cycle","tick",{ tenantId: req.tenant.id, asOf: req.body?.asOf || undefined });
  res.status(202).json({ status:"queued" });
});

cycleRouter.get("/loans/:id/statements", async (req:any,res)=>{
  const c = await pool.connect(); try {
    await c.query(`SET LOCAL app.tenant_id=$1`, [req.tenant.id]);
    const r = await c.query(`SELECT statement_date, cycle_label, file_uri, file_sha256 FROM svc_statements WHERE loan_id=$1 ORDER BY statement_date DESC`, [req.params.id]);
    res.json({ loan_id: req.params.id, statements: r.rows });
  } finally { c.release(); }
});

cycleRouter.get("/loans/:id/vendor-bills", async (req:any,res)=>{
  const c = await pool.connect(); try {
    await c.query(`SET LOCAL app.tenant_id=$1`, [req.tenant.id]);
    const r = await c.query(`SELECT * FROM svc_vendor_bills WHERE loan_id=$1 ORDER BY due_date`, [req.params.id]);
    res.json({ loan_id: req.params.id, bills: r.rows });
  } finally { c.release(); }
});

cycleRouter.get("/loans/:id/disbursements", async (req:any,res)=>{
  const c = await pool.connect(); try {
    await c.query(`SET LOCAL app.tenant_id=$1`, [req.tenant.id]);
    const r = await c.query(`SELECT * FROM svc_disbursements WHERE loan_id=$1 ORDER BY scheduled_date DESC`, [req.params.id]);
    res.json({ loan_id: req.params.id, disbursements: r.rows });
  } finally { c.release(); }
});


Wire into routes.ts:

import { cycleRouter } from "./routes/cycle.routes";
app.use("/api", cycleRouter);

8) Acceptance tests (sanity)

tests/servicing.cycle.test.ts

import { runDailyCycle } from "../src/servicing/cycle";

it("runs daily cycle idempotently", async ()=>{
  const tenantId="00000000-0000-0000-0000-000000000000";
  const asOf="2025-10-01";
  const r1 = await runDailyCycle(tenantId, asOf);
  const r2 = await runDailyCycle(tenantId, asOf); // idempotent -> skipped
  expect(r1.ok).toBe(true);
  expect(r2.skipped).toBe(true);
});

9) What engineering must not change

Cycle idempotency: one svc_cycle_runs per tenant/day; reruns must skip.

Late fee rule: assess after grace on unpaid installment; 5% of P&I (env-configurable).

Statement timing: issue on due date; statement PDF must reflect principal/interest/escrow/fees and delinquency bucket.

Escrow bills: queue 30-day horizon; schedule only when escrow balance suffices; otherwise remain queued.

Disbursement bridge: publish svc.disb#request for Scheduled bills at/after due date; update status on svc.disb#completed.

GL entries: late fees → Debit Cash (1000), Credit Late Fee Income (4100); escrow payouts on settlement → Debit Escrow Liability (2100), Credit Cash (1000).

APIs are read-only in this step—no payment posting here (handled in later steps).

Paths/queues and S3 prefixes exactly as specified.

10) Quick verification checklist

After boarding (Step 14), trigger /api/servicing/cycle/tick.

On a due date, see a statement in S3 & DB (svc_statements), late fee assessed if past grace, delinquency bucket computed.

Vendor bills appear (svc_vendor_bills); if escrow balance sufficient, a svc_disb#request is published and a svc_disbursements row created.

When your disbursement service completes, a svc.disb#completed updates status and GL entries get inserted.

Read-only endpoints return statements, bills, and disbursements.

Step 15 is now fully specified and ready to code: daily cycle engine, statements, late fees, bills, disbursements, GL, workers, APIs, and tests—no decisions left for engineering.