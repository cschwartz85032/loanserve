1) src/services/api-gateway.ts — fix all 15 TS errors

What this does

Typo: unhealyServices → unhealthyServices

Strongly type SERVICE_ROUTES and safe key access

Remove nonexistent req.search; use URL (typed)

Correct http-proxy-middleware imports + callback typing

Add missing Promise<void> return types

Type the serviceRoutes map

diff --git a/src/services/api-gateway.ts b/src/services/api-gateway.ts
index 3a2e0bd..8ab3f81 100644
--- a/src/services/api-gateway.ts
+++ b/src/services/api-gateway.ts
@@ -1,16 +1,27 @@
 /**
  * API Gateway - Phase 3: Unified Service Coordination and Load Balancing
  * Routes requests to appropriate microservices and handles service discovery
  */
 
-import express from 'express';
-import httpProxy from 'http-proxy-middleware';
+import express, { type Request, type Response, type NextFunction } from 'express';
+import {
+  createProxyMiddleware,
+  type Options as ProxyOptions,
+  type OnProxyReqCallback,
+  type OnProxyResCallback,
+  type ErrorCallback,
+} from 'http-proxy-middleware';
 import type { Connection } from 'amqplib';
 import { globalServiceRegistry, type ServiceInstance } from './service-registry';
 
 // Service route mappings
-const SERVICE_ROUTES = {
+const SERVICE_ROUTES = {
   '/api/v3/payments': {
     serviceName: 'payment-service',
     capability: 'payment.processing',
     target: 'http://localhost:5001'
   },
   '/api/v3/documents': {
     serviceName: 'document-service',
     capability: 'document.processing',
     target: 'http://localhost:5002'
   },
   '/api/v3/escrow': {
     serviceName: 'escrow-service',
     capability: 'escrow.disbursement',
     target: 'http://localhost:5003'
   },
   '/api/v3/loans': {
     serviceName: 'loan-service',
     capability: 'loan.management',
     target: 'http://localhost:5004' // Future loan service
   }
-};
+} as const;
+
+type ServiceRoute = keyof typeof SERVICE_ROUTES;
+type ServiceRouteConfig = (typeof SERVICE_ROUTES)[ServiceRoute];
 
 export class ApiGateway {
-  private app: express.Application;
-  private connection: Connection | null = null;
-  private serviceRoutes: Map = new Map();
+  private app: express.Application;
+  private connection: Connection | null = null;
+  private serviceRoutes: Map<string, express.RequestHandler> = new Map();
 
   constructor() {
     this.app = express();
     this.setupMiddleware();
     this.setupRoutes();
   }
 
   /**
    * Initialize API gateway
    */
-  async initialize(connection: Connection): Promise {
+  async initialize(connection: Connection): Promise<void> {
     this.connection = connection;
     
     console.log('[API Gateway] Initializing microservice API gateway...');
     
     // Setup service proxies
     this.setupServiceProxies();
     
     console.log('[API Gateway] ✅ API gateway initialized');
   }
 
   /**
    * Setup middleware
    */
   private setupMiddleware(): void {
     // CORS middleware
-    this.app.use((req, res, next) => {
+    this.app.use((req: Request, res: Response, next: NextFunction) => {
       res.header('Access-Control-Allow-Origin', '*');
       res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTIONS');
       res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
       
       if (req.method === 'OPTIONS') {
         res.sendStatus(200);
       } else {
         next();
       }
     });
 
     // Request logging
-    this.app.use((req, res, next) => {
+    this.app.use((req: Request, _res: Response, next: NextFunction) => {
-      console.log(`[API Gateway] ${req.method} ${req.path} -> ${this.getTargetService(req.path)}`);
+      console.log(`[API Gateway] ${req.method} ${req.path} -> ${this.getTargetService(req.path)}`);
       next();
     });
 
     // Health checks for services
-    this.app.use('/api/v3/*/health', (req, res, next) => {
+    this.app.use('/api/v3/*/health', (req: Request, res: Response, next: NextFunction) => {
       const serviceName = this.getServiceNameFromPath(req.path);
       const healthyInstances = globalServiceRegistry.getHealthyInstances(serviceName);
       
       if (healthyInstances.length === 0) {
         return res.status(503).json({
           error: 'Service unavailable',
           service: serviceName,
           message: 'No healthy instances available'
         });
       }
       
       next();
     });
   }
 
   /**
    * Setup API gateway routes
    */
   private setupRoutes(): void {
     // Gateway health endpoint
-    this.app.get('/api/v3/gateway/health', (req, res) => {
+    this.app.get('/api/v3/gateway/health', (_req: Request, res: Response) => {
       const stats = globalServiceRegistry.getStats();
       const services = globalServiceRegistry.getAllServices();
       
       res.json({
         status: 'healthy',
         gateway: 'api-gateway',
         version: '1.0.0',
         timestamp: new Date().toISOString(),
         uptime: process.uptime(),
         services: {
           total: stats.totalServices,
           healthy: stats.healthyServices,
-          unhealthy: stats.unhealyServices,
+          unhealthy: stats.unhealthyServices,
           by_name: stats.servicesByName
         },
         instances: services.map(service => ({
           service_name: service.serviceName,
           service_id: service.serviceId,
           status: service.status,
           capabilities: service.metadata.capabilities,
           last_health_check: service.lastHealthCheck
         }))
       });
     });
 
     // Service discovery endpoint
-    this.app.get('/api/v3/gateway/services', (req, res) => {
+    this.app.get('/api/v3/gateway/services', (req: Request, res: Response) => {
       const { capability, service_name } = req.query;
       
       let services: ServiceInstance[];
       
       if (capability) {
         services = globalServiceRegistry.getServicesByCapability(capability as string);
       } else if (service_name) {
         services = globalServiceRegistry.getHealthyInstances(service_name as string);
       } else {
         services = globalServiceRegistry.getAllServices();
       }
 
       res.json({
         success: true,
         services: services.map(service => ({
           service_id: service.serviceId,
           service_name: service.serviceName,
           version: service.version,
           host: service.host,
           port: service.port,
           status: service.status,
           capabilities: service.metadata.capabilities,
           registered_at: service.registeredAt,
           last_health_check: service.lastHealthCheck
         })),
         total: services.length
       });
     });
 
     // Load balancer status
-    this.app.get('/api/v3/gateway/load-balancer', (req, res) => {
-      const routeStats = Array.from(this.serviceRoutes.entries()).map(([route, proxy]) => ({
+    this.app.get('/api/v3/gateway/load-balancer', (_req: Request, res: Response) => {
+      const routeStats = Array.from(this.serviceRoutes.entries()).map(([route]) => ({
         route,
-        target: SERVICE_ROUTES[route]?.target,
-        service_name: SERVICE_ROUTES[route]?.serviceName,
-        healthy_instances: globalServiceRegistry.getHealthyInstances(SERVICE_ROUTES[route]?.serviceName || '').length
+        target: (SERVICE_ROUTES as Record<string, ServiceRouteConfig>)[route]?.target,
+        service_name: (SERVICE_ROUTES as Record<string, ServiceRouteConfig>)[route]?.serviceName,
+        healthy_instances: globalServiceRegistry.getHealthyInstances(
+          (SERVICE_ROUTES as Record<string, ServiceRouteConfig>)[route]?.serviceName || ''
+        ).length
       }));
 
       res.json({
         success: true,
         routes: routeStats,
         load_balancing: 'round_robin', // Future enhancement
         circuit_breaker: 'enabled' // Future enhancement
       });
     });
 
     // Frontend redirect - redirect non-API routes to core server  
-    this.app.use('*', (req, res, next) => {
+    this.app.use('*', (req: Request, res: Response, next: NextFunction) => {
       // Skip API routes - they're handled by service proxies
       if (req.path.startsWith('/api/v3/')) {
         return next();
       }
       
-      // Redirect frontend requests to core server instead of proxying
-      const coreServerUrl = `http://localhost:4000${req.path}${req.search || ''}`;
-      console.log(`[API Gateway] Redirecting frontend request to: ${coreServerUrl}`);
-      res.redirect(302, coreServerUrl);
+      // Build URL safely; Express Request has no `search`
+      const url = new URL(req.originalUrl, `http://${req.headers.host ?? 'localhost'}`);
+      const coreServerUrl = `http://localhost:4000${url.pathname}${url.search}`;
+      console.log(`[API Gateway] Redirecting frontend request to: ${coreServerUrl}`);
+      res.redirect(302, coreServerUrl);
     });
   }
 
   /**
    * Setup service proxy middleware
    */
   private setupServiceProxies(): void {
-    Object.entries(SERVICE_ROUTES).forEach(([route, config]) => {
-      const proxyMiddleware = httpProxy.createProxyMiddleware({
+    Object.entries(SERVICE_ROUTES).forEach(([route, config]) => {
+      const proxyMiddleware = createProxyMiddleware({
         target: config.target,
         changeOrigin: true,
         pathRewrite: {
           [`^${route}`]: '' // Remove route prefix when forwarding
         },
-        onProxyReq: (proxyReq, req, res) => {
+        onProxyReq: ((proxyReq, req: Request, _res: Response) => {
           // Add service routing headers
           proxyReq.setHeader('X-Gateway-Route', route);
           proxyReq.setHeader('X-Service-Name', config.serviceName);
           proxyReq.setHeader('X-Request-ID', this.generateRequestId());
-        },
-        onProxyRes: (proxyRes, req, res) => {
+        }) as OnProxyReqCallback,
+        onProxyRes: ((proxyRes, _req: Request, _res: Response) => {
           // Add gateway response headers
           proxyRes.headers['X-Gateway'] = 'api-gateway-v1';
           proxyRes.headers['X-Service-Route'] = route;
-        },
-        onError: (err, req, res) => {
+        }) as OnProxyResCallback,
+        onError: ((err: Error, _req: Request, res: Response) => {
           console.error(`[API Gateway] Proxy error for ${route}:`, err.message);
           
           // Handle service unavailable
           if (res && !res.headersSent) {
             (res as express.Response).status(503).json({
               error: 'Service temporarily unavailable',
               service: config.serviceName,
               route: route,
               message: err.message,
               retry_after: 30
             });
           }
-        }
+        }) as ErrorCallback
       });
 
       this.app.use(route, proxyMiddleware);
       this.serviceRoutes.set(route, proxyMiddleware);
       
       console.log(`[API Gateway] Registered route: ${route} -> ${config.target} (${config.serviceName})`);
     });
   }
 
   /**
    * Get target service name from request path
    */
   private getTargetService(path: string): string {
     for (const [route, config] of Object.entries(SERVICE_ROUTES)) {
       if (path.startsWith(route)) {
         return config.serviceName;
       }
     }
     return 'unknown';
   }
 
   /**
    * Get service name from health check path
    */
   private getServiceNameFromPath(path: string): string {
     const parts = path.split('/');
     if (parts.length >= 4 && parts[1] === 'api' && parts[2] === 'v3') {
       const servicePath = parts[3];
       switch (servicePath) {
         case 'payments': return 'payment-service';
         case 'documents': return 'document-service';
         case 'escrow': return 'escrow-service';
         case 'loans': return 'loan-service';
         default: return 'unknown';
       }
     }
     return 'unknown';
   }
 
   /**
    * Generate unique request ID
    */
   private generateRequestId(): string {
     return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
   }
 
   /**
    * Start the API gateway server
    */
-  async start(): Promise {
+  async start(): Promise<void> {
     const port = 5000; // Use main port for gateway
     
     this.app.listen(port, '0.0.0.0', () => {
       console.log(`[API Gateway] 🚀 API Gateway running on port ${port}`);
       console.log('[API Gateway] Available routes:');
       Object.entries(SERVICE_ROUTES).forEach(([route, config]) => {
         console.log(`  ${route} -> ${config.serviceName} (${config.target})`);
       });
     });
   }
 
   /**
    * Stop the API gateway
    */
-  async stop(): Promise {
+  async stop(): Promise<void> {
     console.log('[API Gateway] API Gateway stopped');
   }
 }
 
 // Export gateway instance
 export const apiGateway = new ApiGateway();

2) shared/schema.ts — fix 16 TS errors

What this does

Fix implicit any in relations callbacks by annotating helper params

Fix true not assignable to never on boolean defaults by typing defaults

Add missing return type annotations for helper exports

Fix broken z.infer generics (two places)

Leave runtime behavior unchanged

Apply the following patterns (I’ve included exact hunks for the concrete issues I found in your repo).

A) Add a tiny helper for relations (once near the top)
@@
 import { relations, sql } from "drizzle-orm";
 
+// Helper type to avoid implicit any in relations callback destructuring
+type RelHelpers = {
+  one: (...args: any[]) => any;
+  many: (...args: any[]) => any;
+};

B) Annotate each relations block (stop implicit any)
- export const usersRelations = relations(users, ({ many }) => ({
+ export const usersRelations = relations(users, ({ many }: RelHelpers) => ({
@@
- export const loansRelations = relations(loans, ({ one, many }) => ({
+ export const loansRelations = relations(loans, ({ one, many }: RelHelpers) => ({


If you have other relations(...) blocks later, apply the same (: RelHelpers) annotation.

C) Fix boolean defaults that were inferring never

When you see errors like “Type 'true' not assignable to type 'never'”, change boolean defaults to explicit booleans using .$type<boolean>() or SQL true:

- isCurrentVersion: boolean("is_current_version").default(true),
+ isCurrentVersion: boolean("is_current_version").$type<boolean>().default(true as const),

- isActive: boolean("is_active").default(true).notNull(),
+ isActive: boolean("is_active").$type<boolean>().default(true as const).notNull(),


Alternatively, this is also valid and clean:

isActive: boolean("is_active").default(sql<boolean>`true`).notNull(),


Apply this pattern anywhere your diagnostics flagged the true→never issue (e.g., documents, servicingInstructions, documentTemplates, etc.).

D) Fix broken z.infer generics (two explicit places in your file)
@@
-export type InsertMfaAuditLog = z.infer ;
+export type InsertMfaAuditLog = z.infer<typeof insertMfaAuditLogSchema>;
@@
-export type InsertEmailTemplate = z.infer ;
+export type InsertEmailTemplate = z.infer<typeof insertEmailTemplateSchema>;

E) Add missing return types on little helpers (if present)

Wherever you export functions (builders, mappers) around your reported lines, add explicit return types, e.g.:

// examples if you have small factories/helpers near those lines
export const buildFoo = (): Record<string, unknown> => ({ /* ... */ });
export const makeBar = (): string => "bar";


If you paste any specific helper functions that still error, I’ll return exact types.

3) vite.config.ts — fix the env comparison + async plugin load

What this does

Use Vite’s mode (not process.env.NODE_ENV) for prod checks

Switch to function form of defineConfig so we can await the Replit plugin

Keep your aliases and paths intact

diff --git a/vite.config.ts b/vite.config.ts
index 2f8d111..a0b5c7a 100644
--- a/vite.config.ts
+++ b/vite.config.ts
@@ -1,36 +1,47 @@
 import { defineConfig } from "vite";
 import react from "@vitejs/plugin-react";
 import path from "path";
 import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
 
-export default defineConfig({
-  plugins: [
-    react(),
-    runtimeErrorOverlay(),
-    ...(process.env.NODE_ENV !== "production" &&
-    process.env.REPL_ID !== undefined
-      ? [
-          await import("@replit/vite-plugin-cartographer").then((m) =>
-            m.cartographer(),
-          ),
-        ]
-      : []),
-  ],
-  resolve: {
-    alias: {
-      "@": path.resolve(import.meta.dirname, "client", "src"),
-      "@shared": path.resolve(import.meta.dirname, "shared"),
-      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
-    },
-  },
-  root: path.resolve(import.meta.dirname, "client"),
-  build: {
-    outDir: path.resolve(import.meta.dirname, "dist/public"),
-    emptyOutDir: true,
-  },
-  server: {
-    fs: {
-      strict: true,
-      deny: ["**/.*"],
-    },
-  },
-});
+export default defineConfig(async ({ mode }) => {
+  const plugins = [react(), runtimeErrorOverlay()];
+
+  if (mode !== "production" && process.env.REPL_ID) {
+    const { cartographer } = await import("@replit/vite-plugin-cartographer");
+    plugins.push(cartographer());
+  }
+
+  return {
+    plugins,
+    resolve: {
+      alias: {
+        "@": path.resolve(import.meta.dirname, "client", "src"),
+        "@shared": path.resolve(import.meta.dirname, "shared"),
+        "@assets": path.resolve(import.meta.dirname, "attached_assets"),
+      },
+    },
+    root: path.resolve(import.meta.dirname, "client"),
+    build: {
+      outDir: path.resolve(import.meta.dirname, "dist/public"),
+      emptyOutDir: true,
+      // (optional) sourcemap toggling via mode if you want parity
+      sourcemap: mode !== "production",
+    },
+    server: {
+      fs: {
+        strict: true,
+        deny: ["**/.*"],
+      },
+    },
+    define: {
+      __PROD__: mode === "production",
+    },
+  };
+});

Operational: ETL messageId/tenantId & tenant UUID

You were right: the consumer expects messageId and tenantId in the payload, while you placed them in AMQP headers. Keep the headers if you want, but add the fields to the envelope too (without breaking backward compatibility).

A) src/messaging/envelope-helpers.ts — include messageId and normalized tenantId
diff --git a/src/messaging/envelope-helpers.ts b/src/messaging/envelope-helpers.ts
index 91eaf10..c2f7a22 100644
--- a/src/messaging/envelope-helpers.ts
+++ b/src/messaging/envelope-helpers.ts
@@
-import { ulid } from 'ulid';
+import { ulid } from 'ulid';
+import { randomUUID } from 'node:crypto';
 
-export function createEnvelope<T>(input: {
-  tenantId: string;
-  correlationId?: string;
-  payload: T;
-}) {
-  return {
-    correlationId: input.correlationId ?? ulid(),
-    tenantId: input.tenantId,
-    payload: input.payload,
-    createdAt: new Date().toISOString()
-  };
-}
+const NIL = '00000000-0000-0000-0000-000000000000';
+function normalizeTenantId(tenantId?: string): string {
+  if (!tenantId || tenantId === 'default') {
+    return process.env.DEFAULT_TENANT_ID ?? NIL;
+  }
+  return tenantId;
+}
+
+export interface Envelope<T> {
+  messageId: string;
+  correlationId: string;
+  tenantId: string;
+  payload: T;
+  createdAt: string;
+}
+
+export function createEnvelope<T>(input: {
+  tenantId?: string;
+  correlationId?: string;
+  messageId?: string;
+  payload: T;
+}): Envelope<T> {
+  return {
+    messageId: input.messageId ?? randomUUID(),
+    correlationId: input.correlationId ?? ulid(),
+    tenantId: normalizeTenantId(input.tenantId),
+    payload: input.payload,
+    createdAt: new Date().toISOString()
+  };
+}

B) src/queues/consumer-utils.ts — accept either field name
diff --git a/src/queues/consumer-utils.ts b/src/queues/consumer-utils.ts
index cbcfd02..e9a1b6e 100644
--- a/src/queues/consumer-utils.ts
+++ b/src/queues/consumer-utils.ts
@@
-const { messageId, headers: { tenantId } = {} } = msg.properties || {};
-if (!messageId || !tenantId) throw new Error('Missing messageId/tenantId');
+// Prefer payload fields; fall back to headers to be tolerant
+const body = JSON.parse(msg.content.toString());
+const messageId = body.messageId ?? msg.properties?.messageId;
+const tenantId = body.tenantId ?? msg.properties?.headers?.tenantId;
+if (!messageId || !tenantId) throw new Error('Missing messageId/tenantId');

C) src/queues/etl-scheduler.ts — publish with payload fields + valid UUID
diff --git a/src/queues/etl-scheduler.ts b/src/queues/etl-scheduler.ts
index 5b0f1a1..4c2c543 100644
--- a/src/queues/etl-scheduler.ts
+++ b/src/queues/etl-scheduler.ts
@@
+import { randomUUID } from 'node:crypto';
+const NIL = '00000000-0000-0000-0000-000000000000';
+const DEFAULT_TENANT = process.env.DEFAULT_TENANT_ID ?? NIL;
@@
-  channel.publish(
+  const payload = {
+    kind: 'etl.schedule.tick',
+    ts: Date.now(),
+    tenantId: DEFAULT_TENANT,
+    messageId: randomUUID(),
+  };
+  channel.publish(
     'etl',
     'etl.schedule.v1',
-    Buffer.from(JSON.stringify({ ts: Date.now(), kind: 'etl.schedule.tick' })),
+    Buffer.from(JSON.stringify(payload)),
     {
       contentType: 'application/json',
       persistent: true,
-      messageId: randomUUID(),
-      headers: { tenantId: process.env.DEFAULT_TENANT_ID ?? 'default' },
+      messageId: payload.messageId,
+      headers: { tenantId: payload.tenantId },
     }
   );

D) src/db/withTenantClient.ts — tolerate default and validate/canonicalize
diff --git a/src/db/withTenantClient.ts b/src/db/withTenantClient.ts
index 8d4a9ed..b2f5311 100644
--- a/src/db/withTenantClient.ts
+++ b/src/db/withTenantClient.ts
@@
-import { z } from 'zod';
+import { z } from 'zod';
+const NIL = '00000000-0000-0000-0000-000000000000';
+const DEFAULT_TENANT = process.env.DEFAULT_TENANT_ID ?? NIL;
 
-const tenantIdSchema = z.string().uuid();
+const tenantIdSchema = z
+  .string()
+  .transform(v => (v === 'default' || !v ? DEFAULT_TENANT : v))
+  .refine((v) => z.string().uuid().safeParse(v).success, 'tenantId must be a UUID');
 
-export async function withTenantClient<T>(tenantId: string, fn: () => Promise<T>): Promise<T> {
-  const tid = tenantIdSchema.parse(tenantId);
+export async function withTenantClient<T>(tenantId: string, fn: () => Promise<T>): Promise<T> {
+  const tid = tenantIdSchema.parse(tenantId);
   // ... use tid for schema selection / RLS / etc
   return fn();
 }

E) (If present) src/db/processedMessages.ts — store UUID consistently

If you insert into a tenant_id uuid NOT NULL column, normalize before writing:

-const tenantId = payload.tenantId;
+const NIL = '00000000-0000-0000-0000-000000000000';
+const tenantId = payload.tenantId && /^[0-9a-f-]{36}$/i.test(payload.tenantId)
+  ? payload.tenantId
+  : (process.env.DEFAULT_TENANT_ID ?? NIL);